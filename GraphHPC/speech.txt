MST
/* тут текст слайда как он есть */

Алгоритмы построения
Существуют различные алгоритмы построения MST, здесь представлены наиболее распространённые из них.
Это алгоритм Примы: который для построения MST сначала выбирает произвольную вершину и начинает растить дерево из неё: на каждом шаге выбирается минимальное ребро, соединяющее уже построенное дерево с вершиной, которая ещё не в дереве, и присоединяет эту вершину к дереву. И так пока не построится дерево.
В алгоритм Крускала все рёбра просматриваются в порядке увеличения веса и в будущее остновное дерево добавляются те из них, которые не создают цикла.
И алгоритм Борувки. Это итеративный (итерационный?) алгоритм, который на каждой итерации для каждой вершины находит ребро минимального веса, инцидентное ей, и объединяет вершины в одну по найденным рёбрам. Поскольку далее речь пойдёт именно об этом алгоритме, рассмотрим его подробнее

Алгоритм Борувки
Более формально алгоритм представлен на слайде. /* прочитать то, что на слайде, объяснить асимптотику */

Подходы к хранению графа
Реализация алгоритма в большой степени определяется тем, как хранится граф.
Далее будут рассмотрены следующие подходы к хранению графа:
Списки смежности - для каждой компоненты перед каждой итерацией явно строится список всех входящих в неё рёбер.
Списки списков смежности - для каждой компоненты хранится список входящих в неё вершин, обход всех рёбер осуществляется обходом вершин, входящих в компоненту, и для каждой вершины обходятся рёбра. Здесь так же существуют модификации, в зависимости от того, какая конкретно структура данных будет выбрана для хранения списка вершин.
И последний вариант предполагает, что исходный массив рёбер не подвергается модификациям по ходу исполнения алгоритма.

Общая схема алгоритма


Списки смежности
Первый подход - списки смежности.
а. В данном подходе это осуществляется простым проходом списка смежности для каждой компоненты.
б. Требуется выделить компоненты, образовавшиеся по рёбра, найденным на предыдущем шаге.
в. Для каждой вершины хранится номер компоненты, в которую она входит: это позволяет быстро определять номер компоненты, в которое ведёт ребро, по индексам инцидентных ей вершин. Для того, чтоб обновить данные номера, используется алгоритм Pointer Jumping
г. И на последнем шаге для каждой образовавшейся компоненты происходит слияния списков рёбер по всем вершинам, котоыре в неё вошли.

Представление в памяти:
Здесь схематично изображена структура графа при данном подходе к хранению графа.

