Задача обработки и анализа больших данных стоит повсеместно и возникает во множестве областей, как то известные поисковики, провайдеры, социальные сети, сотовые операторы, так и в областях,, но достаточно известные: биоинформатика (обработка генов и генных сетей) и многие другие.
Объёмы обрабатываемых данных от десятков гигабайт до террабайт и выше в зависимости от области.
Данные представимы в виде графов: вершины, рёбра или дуги и часто анализ таких данных  сводится к классическим алгоритмам на графах.
Одним из таких алгоритмов является алгоритм построение минимального остовного дерева.

4
Остновным деревом называют ацикличный связный подграф данного связного неориентированного  графа, в который входят все его вершины.
Соответственном минимальное остовное дерево - это остовное дерево на взвешенном графе с минимальной суммой весов входящих в него рёбер.

8
Существуют различные алгоритмы построения MST и на слайде представлены наиболее распространённые из них.
Первый это алгоритм Примы: который для построения MST сначала выбирает произвольную вершину и начинает растить дерево из неё: на каждом шаге выбирается минимальное ребро, соединяющее уже построенное дерево с вершиной, которая ещё не в дереве, и присоединяет эту вершину к дереву. И так пока не построится дерево.
Второй - алгоритм Крускала. В нём рёбра просматриваются в порядке увеличения веса и в будущее остновное дерево добавляются те из них, которые не создают цикла.
И алгоритм Борувки. Это итерационный алгоритм, который на каждой итерации для каждой вершины находит ребро минимального веса, инцидентное ей, и объединяет вершины в одну по найденным рёбрам. 

9
Более формально алгоритм Борувки представлен на слайде.
Нам дан граф G, будущее остовное дерево это мно-во рёбер Т и оно пока что пустое. Далее на каждой итерации вершинами будут компоненты по мно-ву Т, для каждой такой компоненты находим инцидентное ей ребро минимального веса и добавляем его в Т.
Поскольку на каждой итерации мно-во вершин у нас сокращается не менее, чем в два раза, то будет итераций будет не больше, чем двоичный логарифм от вершин, на каждой итерации требуется просмотреть все рёбра и потому итоговая асимптотика получает O(E*logV).

Поскольку далее речь пойдёт именно об этом алгоритме, рассмотрим его подробнее на примере.

14
Анализ алгоритмов.
Если посмотреть на данные алгоритмы с точки зрения параллелизма, то про алгоритмы Крускала и Примы можно сказать, что они состоят из большого количества шагов, между которыми есть явные зависимости и распараллелить их не получится, а вычислительная сложность одного шага достаточно мала и шаг распараллеливать смысла нет.
В алгоритме Борувки всё наборот: шагов немного, но вычислительная сложность одного шага велика и его можно распараллелить. На практике именного его и параллелят.

16
Далее будет идти сравнение реализаций, которое проводилось на RMAT-графах: ???
Тестирование реализаций, представленных далее, проводилось на разных графах, но качественная картинка везде была одинакова. Сравнения в данной презентации представленых на графе RMAT - это граф, структура напоминает структуры социальных сетей, в нём есть как вершины малых степеней, как и вершин, степень которых на 1-2 порядка отличается от средней.
Входные данные в формате CSR - это сжатый формат хранения матриц.
Тестирование проводилось на машине, характеристики которой указаны на слайде. Основным, пожалуй, является то, что это двухсокетная машинка, в каждом процессоре по 8 ядер.



17-20
Схема алгоритма Борувки достаточно простая и реализация в большой степени определяется тем, как хранится граф.
Далее будут рассмотрены следующие подходы к хранению графа:
* Списки смежности - для каждой компоненты перед каждой итерацией явно строится список всех входящих в неё рёбер и для обхода всех рёбер, принадлежащих данной компоненте, достоточно просто пройтись по всему списку. Были так же рассмотрены подварианты в зависимости от сортированности хранимых списков.
* Списки списков смежности - для каждой компоненты хранится список входящих в неё вершин, обход всех рёбер осуществляется обходом вершин, входящих в компоненту, и для каждой вершины обходятся рёбра. Здесь так же существуют модификации, в зависимости от того, * какая конкретно структура данных будет выбрана для хранения списка вершин.
* И последний вариант предполагает, что исходный массив рёбер не подвергается модификациям по ходу исполнения алгоритма и вместо того, чтоб для каждой компоненты хранить, что в неё входит, мы будем для каждой вершины хранить компоненту, которой она принадлежит.



21
Первый подход - списки смежности. ДЛя каждой компоненты явно хранится список всех инцидентных ей рёбер. Под списки понимаются не список именно в значение одно- или двухсвязный список, а любая структура данных, дающах возможность последовательного обхода элементов.

Далее на каждой итерации выполняются следующие шаги:
а. Выбор минимального ребро. В данном подходе это осуществляется простым проходом списка смежности для каждой компоненты и выбора минимального элемента.
б. Требуется выделить компоненты, образовавшиеся по рёбра, найденным на предыдущем шаге. Это делается с помощью обхода в ширину.
в. Для каждой вершины хранится номер компоненты, в которую она входит: это позволяет быстро определять номер компоненты, в которое ведёт ребро, по индексам инцидентных ей вершин. Для того, чтоб обновить данные номера, используется алгоритм Pointer Jumping
г. И на последнем шаге для каждой образовавшейся компоненты происходит слияния списков рёбер по всем вершинам, котоыре в неё вошли.


23
Были так же протестированы варианты с тем, чтоб хранить списки отсортированными (тогда проще найти минимальный элемент - это будет голова списка, но сложнее проходит слияние) и вариант несортированных списков (соответстевнно, дольше искать минимальное ребро, но копирование проходит намного быстрее)
Основные проблемы это дисбаланс на последних итерациях, когда компонент остаётся меньше, чем потоков: в этом случае ядра процессора простаивают и производительность падает. Другая проблема заключается в том, что копировать списки рёбер на каждой итерации - это очень долго.

26.
Для решения обозначенных проблем был выбран следующий подход, в котором для каждой компоненты хранится список не рёбер, а вершин.
В целом алгоритм аналогичен предыдущему подходу. Отличия есть в реалиации первого шага: теперь мы не просто обходим один список, а бежим по списку входящих в компоненту вершин и для каждой вершины обохдим инцидентные ей рёбра. И в последнем шаге: теперь копируем не рёбра, а вершины, которых заметно меньше, что существенно ускоряет данный шаг.

28
Для хранения списков были опробованы как и односвязные списки (такие списки быстро объединяются, но обход таких списков связан со случайными обращениями в память, что очень плохо) и массивы (их объединить не получится, их надо копировать за линейное время, но обходятся они быстрее). Тестирование показало, что массивы ведут себя немного лучше.

29
Проблемы, как ни странно, всё те же, но уже в меньших масштабах.
Проблема с дисбалансом на последних итерациях была решена тем, что списких больших компонент на последних итерациях разделялись между потоками и затем для каждой такой компоненты результатом минимум по всем потокам.
Объединение списков стало заметно быстрее, но по-прежнему долго.

30
Здесь представлено сравнение описанных реализаций.
Самый верхний график это первая реализация. Далее почти рядом идут второй подход на списках и на массивах. И самая эффективная реалиация - это массива с балансировкой больших компонент.

31





Сказать, что такое MTEPS