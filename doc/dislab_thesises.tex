\documentclass{article}

\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{graphicx}
\usepackage{amsmath,amssymb}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{textcomp}
%\usepackage{expdlist}
%\usepackage{textpos}
\usepackage{cmap}
%\usepackage[left=30mm,right=15mm,top=20mm,bottom=20mm]{geometry}

%\hoffset=-3cm
%\textwidth=18cm
%\voffset=-3cm
%\textheight=23cm

\date{}
%\title{Построение MST на мультипроцессоре с ccNUMA архитектурой}
\title{MST на мультипроцессоре: сравнение вариантов алгоритма Борувки}
\author{Зайцев Вадим, zaic101@gmail.com \\ Новосибирский государственный университет\thanks{Работа поддержана Грантом Президента РФ для молодых учёных МК-3644.2014.9}}




\begin{document}

\maketitle
\newpage

%\tableofcontents



\newpage
\section{Введение}
% 1     Введение
% 1.1   Актуальность обработки графов

% 1.2   Постановка задачи MST
В данной работе рассматривается задача построения минимального остовного дерева (minimum spanning tree --- MST) на мультипроцессоре с ccNUMA архитектурой.
Задача построения MST формулируется следующим образом: дан взвешенный, неориентированный граф и требуется найти остовное дерево (максимальный по включению рёбер подграф, не имеющий циклов), в котором сумма весов рёбер будет минимальна.
В случае, когда исходный граф связный, в итоге будет построено остовное дерево, если же в исходном графе несколько компонент, то результатом будет остовной лес.

% 1.3   Применение MST (из английской википедии) % TODO ссылки, более подробное описание
Минимальные остовные деревья имеют широкое практическое применение.
Они используются при построении различных сетей: коммуникационных линий, компьютерных сетей, транспортных сетей.
Так же они используются в кластеризации, сегментации при обработке изображений, распознавании рукописного ввода.

% 1.4   Обзор существующих статей
% ToDo Возможно, полностью перенести в 2.1

\section{Обзор алгоритмов построения MST}
% 2     Подробно об алгоритмах
% 2.1   Обзор существующих
%Существует несколько различных последовательных алгоритмов построения MST. %, которые, в зависимости от используемых в реализации структур данных, имеют асимптотическую оценку времени работы $O(E\cdot\log E)$ для разреженных  и $O(V^2)$ для полных графов.
Существует несколько различных последовательных алгоритмов построения MST, наиболее распространёнными из которых являются алгоритмы Крускала, Прима и Борувки \cite{cormen}.
Алгоритм Крускала состоит из шагов (на каждом шаге добавляется одно новое ребро в текущий остов), каждый следующий из которых зависит от результата предыдущего, что делает распараллеливание данного алгоритма неэффективным.
% TODO описать шаг точно так же
В алгоритме Прима шаги так же связаны между собой, а распараллеливание одного шага не даст большого выигрыша в силу большого количества шагов и малой вычислительной сложности одного шага.
Однако, существует параллельный алгоритм построения MST, являющийся модификацией алгоритма Прима \cite{boruvka-prima}.
Алгоритм Борувки в своём оригинальном виде является наиболее пригодным для распараллеливания. 
%TODO возможно, заменить на псевдокод
Далее опишем подробно алгоритм Борувки и модифицированный алгоритм Прима.


% 2.1.1 Разные реализации Борувки, ПочтиПрима
\subsection{Алгоритм Борувки}
Изначально каждая вершина графа считается отдельной компонентой, затем компоненты объединяются до тех пор, пока не останется ровно одна, либо между оставшимися компонентами не будет рёбер.
Объединение компонент происходит итеративно: на каждой итерации для каждой компоненты просматривается список всех инцидентных ей рёбер (т.е. множество рёбер, инцидентных вершинам, входящим в данную 
% TODO уточнить, что инцидентно хотя бы одной вершине, а не сразу обеим
компоненту) и выбирается минимальное из них, затем компоненты объединяются по найденным рёбрам.

За счёт того, что основная часть алгоритма --- обход всех рёбер, который может быть разбит на независимые части и выполняться параллельно, данный алгоритм в перспективе может дать хорошую масштабируемость.
В статьях \cite{dense-mst,boruvka-prima,boruvka-cm5} представлены различные варианты параллельных реализаций алгоритма Борувки.
Разные реализации используют разные структуры данных для хранения рёбер (хранение рёбер одним большим списком или хранение для каждой вершины списка инцидентных ей рёбер) и разные способы их объединения (слияние и копирование списков, объединение списков за константное время и т. д.).

\subsection{Модифицированный алгоритм Прима}
В статье \cite{boruvka-prima} представлен параллельный алгоритм построения MST на основе последовательного алгоритма Прима.
Суть данного алгоритма в том, что каждый поток выбирает случайную вершину в графе и начинает ``растить'' дерево из выбранной вершины, пока не попытается присоединить вершину, уже принадлежащую другому дереву, после чего два дерева встретившихся потоков объединяются, один из них продолжает ``растить'' объединённое дерево, а второй заново выбирает вершину графа. % TODO перечитать их алгоритм
К преимуществам данного подхода относится отсутствие барьерной синхронизации, которая требуется в алгоритме Борувки после каждой итерации и, в зависимости от реализации, между разными шагами одной итерации.

%\newpage
\section{Параллельные алгоритмы построения MST}
% 2.2   Обзор недостатков существующих
В данных работах \cite{dense-mst,boruvka-prima,boruvka-cm5} результаты производительности показаны либо для старых архитектур \cite{dense-mst,boruvka-cm5}, либо масштабируемость была ограничена шестью одноядерными процессорами (SMP  UMA, UltraSPARC II) \cite{boruvka-prima} .
% 2.2.1 Малое количество ядер
% 2.2.2 SMP системы

% 2.3   Цель работы
Настоящая работа направлена на адаптацию существующих и реализацию новых алгоритмов, ориентированных на высокую эффективность на современных вычислителях с общей памятью с ccNUMA архитектурой.
% TODO не только с общей памятью, но и ускорители типа Intel Xeon Phi, в которых немало ядер?
% И вообще уточнить про количество ядер?

\subsection{Алгоритм Борувки, использующий список рёбер}
% 2.4   Мой алгоритм один
Первая параллельная реализация построения MST основана на алгоритме Борувки. 
Изначально множество вершин графа разделяется между потоками равномерно по количеству инцидентных рёбер.
% TODO уточнить про равномерность вершин и рёбер
Далее на каждой итерации выполняются следующие шаги:
\begin{enumerate}
    \item \textit{Минимальное инцидентное ребро (1)}.
          Каждый поток просматривает своё подмножество рёбер и для каждой компоненты находит инцидентное ребро минимального веса. 
          В результате каждый поток будет иметь массив, содержащий минимальное ребро для каждой компоненты среди просмотренного подмножества.
    \item \textit{Минимальное инцидентное ребро (2)}.
          Происходит редукция: для каждой компоненты находится ребро минимального веса по всем потокам. 
          Таким образом, для каждой компоненты определяется минимальное ребро уже во всём графе.
    \item \textit{Объединение деревьев (1)}.
          Для каждой компоненты определяется её номер на следующей итерации.
          Так же решается проблема с возможными циклами (когда более двух компонент по кругу выберут следующую в качестве ближайшей), которые возможны в алгоритме Борувки при наличии рёбер одинакового веса.
    \item \textit{Объединение деревьев (2)}.
          Осуществляется перенумерация компонент: для каждой вершины вычисляется номер компоненты, в которую она входит, используя параллельный алгоритм Pointer Jumping \cite{pointer-jumping}.
\end{enumerate}
Каждый шаг исполняется параллельно всеми потоками, однако после каждого шага требуется барьерная синхронизация всех потоков.
Далее были сделаны следующие оптимизации:
% TODO либо на каждый шаг вкратце описать профит, либо не описывать его вообще
\begin{itemize}
%    \item Сортировка рёбер по весу и удаление петель, за счёт чего в среднем сокращается количество рёбер, которые необходимо просмотреть на первом шаге.
    \item Сортировка рёбер по весу и удаление петель в исходном графе.
    \item Выделение и инициализация памяти с ориентацией на NUMA архитектуру.
    \item Иерархическая редукция по дереву на втором шаге с учётом NUMA архитектуры.
    \item Оптимизация отсеивания большого количества петель на последних итерациях.
    \item Перенумерация и переупорядовачивание вершин с целью уменьшить объём операций на шаге редукции.
\end{itemize}



% 2.5.3 Результаты
%\textit{ToDo Красивые мимимишные графики}.

\subsection{Алгоритм Борувки, использующий отсортированные списки смежности}
% 2.6   Планы по алгоритму два
% TODO
%Альтернативная параллельная реализация построения MST так же основана на алгоритме Борувки, но для хранения рёбер используются списки смежности для каждой компоненты. 
Наибольшая вычислительная сложность первого алгоритма заключается в первом шаге, в котором необходимо обойти б\`oльшую часть рёбер графа, однако, основным препятствием для хорошей масштабируемости является то, что размер массива, редуцируемого на втором шаге, увеличивается с ростом количества потоков.

Вторая реализация алгоритма Борувки для хранения рёбер использует списки смежности. 
Изначально для каждой вершины сортируется список инцидентных ей рёбер по увеличению веса. 
Таким образом, получить самое лёгкое ребро, инцидентное вершине, возможно за $O(1)$, не выполняя проход по массиву.
Далее выполняются следующие шаги, пока не останется одна компонента:
\begin{enumerate}
    \item \textit{Минимальное инцидентное ребро}.
        Для каждой компоненты берётся инцидентное ей ребро минимального веса. Как отмечено выше, это будет первое ребро из списка смежности.
    \item \textit{Объединение деревьев}.
        Объединение компонент, для каждой компоненты определяется её номер на следующей итерации. 
        Аналогично шагам \textit{Объединение деревьев 1-2} в первом алгоритме.
    \item \textit{Слияние списков}.
        Происходит объединение компонент путём слияния списка рёбер. 
        Поскольку, списки уже отсортированы по возрастанию веса, то возможно слияние, при котором в результате так же будет получен отсортированный список, с сохранением линейного времени работы.
    \item \textit{Перенумерация}.
        Обход списков рёбер и перенумерация компонент: старые номера заменяются на новые, полученные на шаге \textit{Объединения деревьев}.
\end{enumerate}

В ходе анализа работы шага \textit{Объединение деревьев} на тестируемых типах графов было выяснено, что количество объединяемых компонент в одну в большинстве случаев не превосходит трёх-пяти и это позволяет быстро и эффективно отсеивать петли на шаге \textit{Слияния списков} за счёт сокращения нерегулярных обращений в память.

% TODO список применённых или планируемых оптимизаций

\subsection{Алгоритм Борувки, использующий неотсортированные списки смежности}

% TODO ударения в слове большИх
Поддержка списков смежности отсортированными при слиянии требует больших временных затрат и несмотря на получившийся выигрыш в первом шаге, общее время выполнение алгоритма увеличилось.
В связи с этим было решено отказаться от поддержания списков отсортированными. Таким образом, поиск минимума на первом шаге осуществляется обходом всего списка, но объединение списков стало возможно простым копированием.
% TODO хоть и не реализовывалось, но упомянуть, что минимум по-прежнему можно находить за константу, если объединить с последним шагом предыдущей итерации

Общая схема алгоритма осталась прежней, однако, реализация шага поиска минимального ребра и слияния списков значительно изменилась.
%\begin{enumerate}
%    \item \textit{Минимальное инцидентное ребро}.
%        Для каждой компоненты находится инцидентное ей ребро минимального веса простым линейным поиском.
%    \item \textit{Объединение деревьев}.
%        Объединение компонент, для каждой компоненты определяется её номер на следующей итерации. 
%        Аналогично шагам \textit{Объединение деревьев 1-2} в первом алгоритме.
%    \item \textit{Слияние списков}.
%        Происходит объединение компонент путём объединения списка рёбер.
%    \item \textit{Перенумерация}.
%        Обход списков рёбер и перенумерация компонент: старые номера заменяются на новые, полученные на шаге \textit{Объединения деревьев}.
%\end{enumerate}

% TODO dfs, bfs и т.п. (PJ по идее в следующей subsection)

\subsection{Алгоритм Борувки, использующий списки списков смежности}

Наибольшая временная сложность при хранении списков смежности каждой компоненты заключается в шаге \textit{слияния списков}, где на каждой итерации происходит просмотр и копирование всех рёбер
Несмотря на то, что от итерации к итерации количество рёбер значительно сокращается, большой объём копируемых данных негативно сказывается на общей производительности такой реализации.
% TODO пруф с картинкой?

Уменьшить объём копируемых данных возможно за счёт копирования не рёбер, входящих в компоненту, а вершин. Здесь возможно применить два подхода:
\begin{itemize}
	\item Хранить множество вершин компоненты в виде списка. Это даёт возможность объединять две компоненты за константное время, однако, связано со увеличением количества случайных обращений в память при поиске минимума.
	\item Хранить множество вершин компоненты в виде динамического массива. При таком подходе объединение двух компонент будет проходить за время, пропорциональное размеру меньшего из списков, но обход всех вершин компонент будет происходить быстрее.
\end{itemize}


%Шаги:
%Минимальное инцидентное ребро
%Объединение деревьев
%(балансировка)
%PJ
%Слияние списков


%Разные алгоритмы поиска компонент

%\newpage
\section{Результаты}
% 2.5   На чём проводилось тестирование
% 2.5.1 Параметры графов
Тестирование проводилась на графах, состоящих из $10^6-10^8$ вершин и $10^7-10^9$ рёбер: это RMAT и SSCA2 графы степени $20\,-\,23$, двумерные и трёхмерные решётки, а так же случайные графы.
Запуски проводились на машине с двумя процессорами Intel Xeon CPU E5-2690 (8 ядер 2.9 GHz, 32KB L1 cache, 256KB L2 cache, 20MB L3 cache) и 64 гигабайтами оперативной памяти.

В ходе тестирования наилучшие результаты были показаны реализацией, использующей единый список для хранения всех рёбер. Хорошие результаты были показаны вариантом, использующим списки списков смежности.
Реализации, перестраивающие списки смежности для образовавшихся компонент на каждой итерации, показали более худшие результаты из-за копирования больших объёмов данных на каждой итерации. 

% 2.5.2 Характеристика систем
%Характеристики систем, на которых производились запуски:
%\begin{itemize}
%    \item 2 $\times$ Intel Xeon CPU E5-2690 (8 ядер 2.9 GHz, 32KB L1 cache, 256KB L2 cache, 20MB L3 cache)
%    \item 8 $\times$ Intel Xeon CPU Е7-4870 (10 ядер 2.4 GHz, 32KB L1 cache, 256KB L2 cache, 30MB L3 cache)
%\end{itemize}

%[Позже будут добавлены результаты тестирования двух описанных алгоритмов].

%\newpage
\section{Заключение}
На данный момент исследованы последовательные алгоритмы построения остовных деревьев и выбраны из них те, которые или модификации которых могут дать хорошую масштабируемость при распараллеливании. Так же изучены статьи  \cite{dense-mst,boruvka-prima,boruvka-cm5} по распараллеливанию данных алгоритмов.

Были написаны последовательные реализации алгоритмов для дальнейшей проверки корректности получаемых результатов. Затем был написан и распараллелен алгоритм Борувки в нескольких реализациях, использующих разные структуры данных для хранения графа.

В дальнейших планах есть как оптимизация существующих алгоритмов, так и реализация новых.

%В уже реализованных алгоритмах ближайшей целью является использование таких подходов как параллельные %алгоритмы поиска компонент связности в тех шагах, где происходит объединение вершин одной компоненты.

Возможно использование других  структур данных в алгоритме Борувки. 
На данный момент рассматриваются такие структуры данных, как деревья или кучи, позволяющие при дополнительных условиях производить их слияние за время, пропорциональное их высоте.
%Рассматриваются такие структуры, как списки отсортированных списков смежностей, являющиеся промежуточным %вариантом между поддержанием списков смежностей отсортированными на каждой итерации и полным отказом от %сортировки списков, и 

Также планируется не только модификация алгоритма Борувки, но и реализация асинхронного алгоритма построения остовного дерева. Например, модифицированного алгоритма Прима.

\newpage
\bibliographystyle{unsrt}
\bibliography{conference}

\end{document}
