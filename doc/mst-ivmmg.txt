2. Сначала я сформулирую задачу, затем расскажу о последовательных алгоритмах решения задачи, далее перейду к распараллеливанию данных алгоритмов и в концу будут представлены результаты и дальнейшие планы

3. MST - остовное дерево в английской литературе. V, E. Сказать про дерево и лес.

4. Существует несколько различных последовательных алгоритмов построения MST, рассмотрим их подробно. Первый из них -- алгоритм Крускала.

5. Существую и более экзотические структуры данных, но на практике оно не эффективны.

6. Следующий алгоритм так же жадный и это алгоритм Борувки. Это итерационный алгоритм, который постепенно строит остовное дерево. G(V, T) -- лес, который растёт и постепенно становится деревом.

11. Борувка - кандидат номер 1. Модифицированный Прима - кандидат номер 2.

12. Итак, на основе алгоритма Борувки был разработан первый вариант параллельного алгоритма построения MST.
Алгоритм следующий. Изначально мно-во всех вершин графа разбивается равномерно между потоками. Изначально разбиение было равномерным по количеству рёбер, однако, равномерное распределение некоторых величин в генераторах используемых графов позволяет разбивать граф равномерно по количеству вершин между потоками, что несколько упрощает реализацию.
Множество рёбер графа представлено в памяти одним непрерывным массивом, который никак не модифицируется по ходу исполнения алгоритма. (можно показать следующий слайд).

Далее на каждой итерации алгоритма Борувки выполняются следующие шаги:
а. Каждый поток обходит свой список вершин и для каждой компоненты, которая представлена хотя бы одной вершиной, находит минимальное инцидентное ей ребро.
б. Поскольку в одну компонету по ходу выполнения алгоритма могут входить вершины, принадлежащие разным потокам, то после выполнения шага (а) требуется осуществить редукцию минимальных рёбер для каждой компоненты по всем потокам. И т.о. для компоненты найдётся минимальное ребро.
с. Далее найденные рёбра добавляются в остовное дерево и происходит объединение компонент по этим рёбрам. Так же разрешаются проблемы с циклами, когда две компоненты указывают друг на друга.
д. И в конце осуществляется перенумерация компонент с использованием параллельного алгоритма сжатия путей Pointer Jumping.

13. Разные цвета -- разные компоненты. На изображении показано, что рёбра одной компоненты могут принадлежать разным потокам.

14. Далее были сделаны следующие оптимизации:
* Для каждой вершины список её вершин был отсортирован по весу. Это позволяет быстро отсечь рёбра, которые заведомо хуже текущего результата и сократить количество просмотренных рёбер на каждой итерации.
* Выделение и инициализация всей памяти не в основном потоке, а инициализация каждым потоком тех данных, которые он будет использовать. Это связано с особенностью NUMA-архитектур.
* Редукция по дереву на вотором шаге. Здесь так же учитывалась особенность NUMA-архитектур: изначально редукция происходит внутри каждого сокета, а затем - между сокетами.

16. Так же были выявлены следующие проблемы: * Шаг (а) имеют наибольшую вычислительную мощность, т.к. на каждой итерации требуется обойти большое количество рёбер и обход рёбер связан со случайными обращениями в память.

17. * Шаг с редукцией является сложно масштабируемым, т.к. с ростом числа потоков растёт и количество вычислений, т.е. независимо от числа потоков, объём работы каждого из них не будет уменьшаться.
* Время выполнения шагов (c) и (d) сравнительно мало, потому с ними проблем нет.

19. Эти проблемы было решено исправить, используя для хранения рёбер не один исходный массив рёбер, а списки смежностей для каждой компоненты. Если ранее рёбра компоненты были "разбросаны" в памяти по спискам рёбер каждой из вершин компоненты, то теперь они хранятся подряд в одном списке, который, что важно, поддерживается отсортированным по весу.

20. Слияние отсортированных списков методом, аналогичным в "сортировке слиянием". Слияемых списков немного.