Сначала я расскажу о своей задаче и о существующих последовательных алгоритмах её решения, затем о возможности распараллеливания данных алгоритмов и далее речь пойдёт об одном конкретном алгоритме - алгоритме Борувки.

MST
/* тут текст слайда как он есть */

Алгоритмы построения
Существуют различные алгоритмы построения MST и сейчас будут представлены наиболее распространённые из них.

Первый это алгоритм Крускала. В нём рёбра просматриваются в порядке увеличения веса и в будущее остновное дерево добавляются те из них, которые не создают цикла.

Второй это алгоритм Примы: который для построения MST сначала выбирает произвольную вершину и начинает растить дерево из неё: на каждом шаге выбирается минимальное ребро, соединяющее уже построенное дерево с вершиной, которая ещё не в дереве, и присоединяет эту вершину к дереву. И так пока не построится дерево.

И алгоритм Борувки. Это итеративный (итерационный?) алгоритм, который на каждой итерации для каждой вершины находит ребро минимального веса, инцидентное ей, и объединяет вершины в одну по найденным рёбрам. 
Поскольку далее речь пойдёт именно об этом алгоритме, рассмотрим его подробнее на примере.
Алгоритм Борувки
Более формально алгоритм представлен на слайде. /* прочитать то, что на слайде, объяснить асимптотику */

Анализ алгоритмов
/* прочитать слайд *.
Сказать, что алгоритм Примы распараллеливать пытаются.
Сказать, что с Крускалом тоже пытаются что-то делать.

Немного о графе, матрицах и машинках.

Подходы к хранению графа
Реализация алгоритма в большой степени определяется тем, как хранится граф.
Далее будут рассмотрены следующие подходы к хранению графа:
Списки смежности - для каждой компоненты перед каждой итерацией явно строится список всех входящих в неё рёбер.
Списки списков смежности - для каждой компоненты хранится список входящих в неё вершин, обход всех рёбер осуществляется обходом вершин, входящих в компоненту, и для каждой вершины обходятся рёбра. Здесь так же существуют модификации, в зависимости от того, какая конкретно структура данных будет выбрана для хранения списка вершин.
И последний вариант предполагает, что исходный массив рёбер не подвергается модификациям по ходу исполнения алгоритма.

Общая схема алгоритма


Списки смежности
Первый подход - списки смежности. Сказать, что списки - это не списки.
а. В данном подходе это осуществляется простым проходом списка смежности для каждой компоненты.
б. Требуется выделить компоненты, образовавшиеся по рёбра, найденным на предыдущем шаге.
в. Для каждой вершины хранится номер компоненты, в которую она входит: это позволяет быстро определять номер компоненты, в которое ведёт ребро, по индексам инцидентных ей вершин. Для того, чтоб обновить данные номера, используется алгоритм Pointer Jumping
г. И на последнем шаге для каждой образовавшейся компоненты происходит слияния списков рёбер по всем вершинам, котоыре в неё вошли.

Представление в памяти:
Здесь схематично изображена структура графа при данном подходе к хранению графа.




Сказать, что такое MTEPS