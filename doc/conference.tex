\documentclass{article}

\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{graphicx}
\usepackage{amsmath,amssymb}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{textcomp}
%\usepackage{expdlist}
%\usepackage{textpos}
\usepackage{cmap}
%\usepackage[left=30mm,right=15mm,top=20mm,bottom=20mm]{geometry}

%\hoffset=-3cm
%\textwidth=18cm
%\voffset=-3cm
%\textheight=23cm

\date{}
\title{Построение MST на мультипроцессоре с ccNUMA архитектурой}
\author{Зайцев Вадим, zaic101@gmail.com \\ Новосибирский государственный университет\thanks{Работа поддержана Грантом Президента РФ для молодых учёных МК-3644.2014.9}}




\begin{document}

\maketitle



% 1     Введение
% 1.1   Актуальность обработки графов

% 1.2   Постановка задачи MST
В данной работе рассматривается задача построения минимального остовного дерева (minimum spanning tree -- MST) на мультипроцессоре с ccNUMA архитектурой.
Задача построения MST формулируется следующим образом: дан взвешенный, неориентированный граф и требуется найти остовное дерево (максимальный по включению рёбер подграф, не имеющий циклов), в котором сумма весов рёбер будет минимальна.
В случае, когда исходный граф связный, в итоге будет построено остовное дерево, если же в исходном графе несколько компонент, то результатом будет лес.

% 1.3   Применение MST (из английской википедии) % TODO ссылки, более подробное описание
Минимальные остовные деревья имеют широкое практическое применение.
Они используются при построении различных сетей: коммуникационных линий, компьютерных сетей, транспортных сетей.
Так же они используются в кластеризации, сегментации при обработке изображений, распозновании рукописного ввода.

% 1.4   Обзор существующих статей
% ToDo Возможно, полностью перенести в 2.1

% 2     Подробно об алгоритмах
% 2.1   Обзор существующих
%Существует несколько различных последовательных алгоритмов построения MST. %, которые, в зависимости от используемых в реализации структур данных, имеют асимптотическую оценку времени работы $O(E\cdot\log E)$ для разреженных  и $O(V^2)$ для полных графов.
Существует несколько различных последовательных алгоритмов построения MST, наиболее распространёнными из которых являются алгоритмы Крускала, Прима и Борувки \cite{cormen}.
Алгоритм Крускала состоит из шагов (на каждом шаге добавляется одно новое ребро в текующий остов), каждый следующий из которых зависит от результата предыдущего, что делает распараллеливание данного алгоритма неэффективным.
% TODO описать шаг точно так же
В алгоритме Прима шаги так же связаны между собой, а распараллеливание одного шага не даст большого выигрыша в силу большого количества шагов и малой вычислительной сложности одного шага.
Однако, существует параллельный алгоритм построения MST, являющийся модификацией алгоритма Прима.
Алгоритм Борувки в своём оригинальном виде является наиболее пригодным для распараллеливания. 
%TODO возможно, заменить на псевдокод
Далее опишем алгоритм Борувки и модифицированный алгоритм Прима.


% 2.1.1 Разные реализации Борувки, ПочтиПрима
\textit{Алгоритм Борувки}. 
Изначально каждая вершина графа считается отдельной компонентой, затем компоненты объединяются до тех пор, пока не останется ровно одна.
Объединение компонент происходит итеративно: на каждой итерации для каждой компонеты просматривается список всех инцидентных ей рёбер и выбирается минимальное из них, затем компоненты объединяются по найденным рёбрам.
За счёт того, что основная часть алгоритма -- обход всех рёбер, который может быть разбит на независимые части и выполнятся параллельно, данный алгоритм в перспективе может дать хорошую масштабируемость.
В статьях \cite{dense-mst,boruvka-prima,boruvka-cm5} представлены различные варианты параллельных реализаций алгоритма Борувки.
Разные реализации используют разные структуры данных для хранения рёбер (хранение рёбер одним большим списком или хранение для каждой вершины списка инцидентных ей рёбер) и разные способы их объединения (слияние и копирование списков, объединение списков за константное время и т. д.).

\textit{Модифицированный алгоритм Прима}.
В статье \cite{boruvka-prima} представлен параллельный алгоритм построения MST на основе последовательного алгоритма Прима.
Суть данного алгоритма в том, что каждый поток выбирает случайную вершину в графе и начинает ``растить'' дерево из выбранной вершины, пока не попытается присоединить вершину, уже принадлежащую другому дереву, после чего два дерева встретившихся потоков объединяются, один из них продолжает ``растить'' объединённое дерево, а второй заново выбирает вершину графа. % TODO перечитать их алгоритм
К преимуществам данного подхода относится отсутствие барьерной синхронизации, которая требуется в алгоритме Борувки после каждой итерации и, в зависимости от реализации, между разными шагами одной итерации.

% 2.2   Обзор недостатков существующих
В данных работах \cite{dense-mst,boruvka-prima,boruvka-cm5} результаты производительности показаны либо для старых архитектур \cite{dense-mst,boruvka-cm5}, либо масштабируемость была ограничена шестью одноядерными процессорами (SMP  UMA, UltraSPARC II) \cite{boruvka-prima} .
% 2.2.1 Малое количество ядер
% 2.2.2 SMP системы

% 2.3   Цель работы
Настоящая работа направлена на адаптацию существующих и реализацию новых алгоритмов, ориентированных на высокую эффективность на современных вычислителях с общей памятью с ccNUMA архитектурой.

% 2.4   Мой алгоритм один
Первая параллельная реализация построения MST основана на алгоритме Борувки. 
Изначально множество вершин графа разделяется между потоками равномерно по количеству инцидентных рёбер.
Далее на каждой итерации выполняются следующие шаги:
\begin{enumerate}
    \item \textit{Минимальное инцидентное ребро (1)}.
          Каждый поток просматривает своё подмножество рёбер и для каждой компоненты находит инцидентное ребро минимального веса. 
          В результате каждый поток будет иметь массив, содержащий минимальное ребро для каждой компоненты среди просмотренного подмножества.
    \item \textit{Минимальное инцидентное ребро (2)}.
          Происходит редукция: для каждой компоненты находится ребро минимального веса по всем потокам. 
          Таким образом, для каждой компоненты определяется минимальное ребро уже по всему графу.
    \item \textit{Объединение деревьев (1)}.
          Для каждой компонеты определяется её номер на следующей итерации.
          Так же решается проблема с возможными циклами (когда более двух компонент по кругу выберут следующую в качестве ближайшей), которые возможны в алгоритме Борувки при наличии рёбер одинакового веса.
    \item \textit{Объединение деревьев (2)}.
          Осуществляется перенумерация компонент: для каждой вершины вычисляется номер компонеты, в которую она входит, используя параллельный алгоритм Pointer Jumping \cite{pointer-jumping}.
\end{enumerate}
Каждый шаг исполняется параллельно всеми потоками, однако после каждого шага требуется барьерная синхронизация всех потоков.
Далее были сделаны следующие оптимизации:
\begin{itemize}
    \item Сортировка рёбер по весу и удаление петель, за счёт чего в среднем сокращается количество рёбер, которые необходимо просмотреть на первом шаге.
    \item Выделение и инициализация памяти с ориентацией на NUMA архитектуру.
    \item Иерархическая редукция по дереву на втором шаге с учётом NUMA архитектуры.
\end{itemize}



% 2.5.3 Результаты
%\textit{ToDo Красивые мимимишные графики}.

% 2.6   Планы по алгоритму два
% TODO
%Альтернативная параллельная реализация построения MST так же основана на алгоритме Борувки, но для хранения рёбер используются списки смежности для каждой компоненты. 
Наибольшая вычислительная сложность первого алгоритма заключается в первом шаге, в котором необходимо обойти б\`oльшую часть рёбер графа, однако, основным препятствием для хорошей масштабируемости является то, что размер массива, редуцируемого на втором шаге, увеличивается с ростом количества потоков.

Вторая реализация алгоритма Борувки для хранения рёбер использует списки смежности. 
Изначально для каждой вершины сортируется список инцидентных ей рёбер по увеличению веса. 
Таким образом, получить самое лёгкое ребро, инцидентное вершине, возможно за $O(1)$, не выполняя проход по массиву.
Далее выполняются следующие шаги, пока не останется одна компонента:
\begin{enumerate}
    \item \textit{Минимальное инцидентное ребро}.
        Для каждой компоненты берётся инцидентное ей ребро минимального веса. Как отмечено выше, это будет первое ребро из списка смежности.
    \item \textit{Объединение деревьев}.
        Объединение компонент, для каждой компоненты определяется её номер на следующей итерации. 
        Аналогично шагам \textit{Объединение деревьев 1-2} в первом алгоритме.
    \item \textit{Слияние списков}.
        Происходит объединение компонент путём слияния списка рёбер. 
        Поскольку, списки уже отсортированы по возрастанию веса, то возможно слияние, при котором в результате так же будет получен отсортированный список, с сохранением линейного времени работы.
    \item \textit{Перенумерация}.
        Обход списков рёбер и перенумерация компонент: старые номера заменяются на новые, полученные на шаге \textit{Объединения деревьев}.1
\end{enumerate}

%На тестируемых типах графов количество компонент, объединяемых на шаге \textit{Объединение деревьев} в одну, в большинстве случаев не превосходит 3 и это позволяет быстро и эффективно отсеивать петли на шаге \textit{Слияния списков} за счёт сокращения нерегулярных обращений в память.
В ходе анализа работы шага \textit{Объединение деревьев} на тестируемы типах графов было выяснено, что количество объединяемых компонент в одну в большинстве случаев не преводсходит трёх и это позволяет быстро и эффективно отсеивать петли на шаге \textit{Слияния списков} за счёт сокращения нерегулярных обращений в память.

% 2.5   На чём проводилось тестирование
% 2.5.1 Параметры графов
Тестирование проводилась на графах, состоящих из $10^6-10^8$ вершин и $10^7-10^9$ рёбер: это RMAT-графы степени $20\,-\,23$, двумерные и трёхмерные решётки, а так же случайные графы.

% 2.5.2 Характеристика систем
Характеристики систем, на которых производились запуски:
\begin{itemize}
    \item 2 $\times$ Intel Xeon CPU E5-2690 (8 ядер 2.9 GHz, 32KB L1 cache, 256KB L2 cache, 20MB L3 cache)
    \item 8 $\times$ Intel Xeon CPU Е7-4870 (10 ядер 2.4 GHz, 32KB L1 cache, 256KB L2 cache, 30MB L3 cache)
\end{itemize}

%[Позже будут добавлены результаты тестирования двух описанных алгоритмов].

\bibliographystyle{unsrt}
\bibliography{conference}

\end{document}
